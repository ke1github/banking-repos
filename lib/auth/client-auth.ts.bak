"use client";

import { translateAppwriteError } from "@/lib/utils/appwrite-errors";
import { logAuthError } from "@/lib/utils/client-logger";
import { account } from "@/lib/appwrite/config";
import { AppwriteException, Models } from "appwrite";

/**
 * Helper for handling Appwrite operations with standardized error handling
 */
async function withErrorHandling<T>(
  operation: () => Promise<T>,
  context: string,
  metadata: Record<string, string | number | boolean | undefined> = {}
): Promise<{ success: true; result: T } | { success: false; error: string }> {
  try {
    const result = await operation();
    return { success: true, result };
  } catch (error) {
    // Translate error to a consistent format
    const translatedError = translateAppwriteError(
      error,
      context,
      `${context} failed`
    );

    // Log the error
    logAuthError(error, context, {
      ...metadata,
      errorCode: translatedError.code,
    });

    return {
      success: false,
      error: translatedError.userMessage,
    };
  }
}

/**
 * Client-side wrapper for Appwrite authentication operations
 * Provides consistent error handling and logging
 */
export const clientAuth = {
  /**
   * Get the current user (with error handling)
   */
  async getUser(): Promise<Models.User<Models.Preferences> | null> {
    try {
      return await account.get();
    } catch (error) {
      if (
        error instanceof Error &&
        error instanceof AppwriteException &&
        error.code === 401
      ) {
        // Not logged in - this is normal
        return null;
      }

      // Log other errors
      logAuthError(error, "client_get_user");
      return null;
    }
  },

  /**
   * Check if the current user is logged in
   */
  async isLoggedIn(): Promise<boolean> {
    try {
      const user = await account.get();
      return Boolean(user?.$id);
    } catch {
      return false;
    }
  },

  /**
   * Log in a user with email and password
   */
  async login(
    email: string,
    password: string
  ): Promise<{
    success: boolean;
    user?: Models.User<Models.Preferences>;
    error?: string;
  }> {
    const result = await withErrorHandling(
      async () => {
        await account.createSession(email, password);
        return await account.get();
      },
      "client_login",
      { email }
    );

    if (result.success) {
      return { success: true, user: result.result };
    } else {
      return { success: false, error: result.error };
    }
  },

  /**
   * Log out the current user
   */
  async logout(): Promise<{ success: boolean; error?: string }> {
    const result = await withErrorHandling(
      async () => await account.deleteSession("current"),
      "client_logout"
    );

    return result.success
      ? { success: true }
      : { success: false, error: result.error };
  },
};
